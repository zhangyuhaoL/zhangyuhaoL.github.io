<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="来源：浪里行舟 前端模块化详解 在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。 模块化的理解 什么是模块   将一个复杂的程">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础知识汇总（Javascript）">
<meta property="og:url" content="https://zhangyuhaoL.github.io/2019/09/04/前端基础汇总2/index.html">
<meta property="og:site_name" content="Shmily-ll">
<meta property="og:description" content="来源：浪里行舟 前端模块化详解 在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。 模块化的理解 什么是模块   将一个复杂的程">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://zhangyuhaol.github.io/2019/09/04/前端基础汇总2/前端模块化.png">
<meta property="og:image" content="https://zhangyuhaol.github.io/2019/09/04/前端基础汇总2/XXX">
<meta property="og:updated_time" content="2019-09-10T10:05:16.913Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端基础知识汇总（Javascript）">
<meta name="twitter:description" content="来源：浪里行舟 前端模块化详解 在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。 模块化的理解 什么是模块   将一个复杂的程">
<meta name="twitter:image" content="https://zhangyuhaol.github.io/2019/09/04/前端基础汇总2/前端模块化.png">





  
  
  <link rel="canonical" href="https://zhangyuhaoL.github.io/2019/09/04/前端基础汇总2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>前端基础知识汇总（Javascript） | Shmily-ll</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shmily-ll</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">要是记不住，就多写写吧</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zhangyuhaoL.github.io/2019/09/04/前端基础汇总2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyuhao">
      <meta itemprop="description" content="JavaScript,React,Vue">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shmily-ll">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端基础知识汇总（Javascript）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-04T00:00:00+08:00">2019-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-10 18:05:16" itemprop="dateModified" datetime="2019-09-10T18:05:16+08:00">2019-09-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>来源：<a href="https://github.com/ljianshu/Blog" target="_blank" rel="noopener">浪里行舟</a></p>
<h3 id="前端模块化详解"><a href="#前端模块化详解" class="headerlink" title="前端模块化详解"></a><div align="center">前端模块化详解</div></h3><hr>
<p>在 JavaScript 发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今 CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着 web2.0 时代的到来，Ajax 技术得到广泛应用，jQuery 等前端库层出不穷，前端代码日益膨胀，此时在 JS 方面就会考虑使用模块化规范去管理。<br><img src="/2019/09/04/前端基础汇总2/前端模块化.png" alt="前端模块化"></p>
<h4 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h4><ol>
<li>什么是模块</li>
</ol>
<ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信<a id="more"></a>
</li>
</ul>
<ol start="2">
<li>模块化的进化过程<ul>
<li>全局 function 模式 : 将不同的功能封装成不同的全局函数<ul>
<li>编码: 将不同的功能封装成不同的全局函数</li>
<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>
</ul>
</li>
<li>namespace 模式 : 简单对象封装<ul>
<li>作用: 减少了全局变量，解决命名冲突</li>
<li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li>
</ul>
</li>
<li>IIFE 模式：匿名函数自调用(闭包)<ul>
<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给 window 添加属性来向外暴露接口</li>
<li>问题: 如果当前这个模块依赖另一个模块怎么办?</li>
</ul>
</li>
</ul>
</li>
<li>模块化的好处</li>
</ol>
<ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
<ol start="4">
<li>引入多个\&lt;script>后出现出现问题</li>
</ol>
<ul>
<li>请求过多</li>
<li>依赖模糊</li>
<li>难以维护</li>
</ul>
<h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><ol>
<li><p>CommonJS</p>
<ul>
<li>概述<br>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</li>
<li>特点<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
</li>
<li>基本语法<ul>
<li>暴露模块：module.exports = value 或 exports.xxx = value</li>
<li>引入模块：require(xxx),如果是第三方模块，xxx 为模块名；如果是自定义模块，xxx 为模块文件路径<br>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。<strong>这个变量是一个对象</strong>，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>); <span class="comment">//如果参数字符串以“./”开头，则表示加载的是一个位于相对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(example.x); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(example.addX(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>require 命令用于加载模块文件。require 命令的基本功能是，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错。</p>
<ul>
<li>模块的加载机制<br>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
</ul>
</li>
<li><p>AMD<br>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用 AMD 规范。</p>
<ul>
<li>AMD 规范基本语法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义暴露模块:</span></span><br><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define([<span class="string">'module1'</span>, <span class="string">'module2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入使用模块:</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'module1'</span>, <span class="string">'module2'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//使用m1/m2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMD<br>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD 规范整合了 CommonJS 和 AMD 规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD 模块定义规范。</p>
</li>
<li><p>ES6 模块化<br>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<ul>
<li><p>ES6 模块化语法<br>export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。<br><code>javascript /** 定义模块 math.js **/ var basicNum = 0; var add = function(a, b) { return a + b; }; export { basicNum, add }; /** 引用模块 **/ import { basicNum, add } from &#39;./math&#39;; function test(ele) { ele.textContent = add(99 + basicNum); }</code><br>使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到 export default 命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模块默认输出, 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 模块与 CommonJS 模块的差异</p>
<ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。<br>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>CommonJS 规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了 AMD CMD 解决方案。</li>
<li>AMD 规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD 规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。</li>
<li>CMD 规范与 AMD 规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在 Node.js 中运行。不过，依赖 SPM 打包，模块的加载逻辑偏重</li>
<li><strong>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</strong></li>
</ul>
<h3 id="跨域方式实现原理"><a href="#跨域方式实现原理" class="headerlink" title="跨域方式实现原理"></a><div align="center">跨域方式实现原理</div></h3><hr>
<h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><ol>
<li>同源策略及其限制内容<br>同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</li>
</ol>
<p>同源策略限制内容有：</p>
<ul>
<li>Cookie、LocalStorage、IndexedDB 等存储性内容</li>
<li>DOM 节点</li>
<li>AJAX 请求发送后，结果被浏览器拦截了</li>
</ul>
<p>有三个标签是允许跨域加载资源：</p>
<ul>
<li>\<img src="/2019/09/04/前端基础汇总2/XXX"></li>
<li>\<link href="XXX"></li>
<li>\<script src="XXX"></li>
</ul>
<ol start="2">
<li>常见跨域场景<br>当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算作“跨域”。</li>
</ol>
<p>特别说明：</p>
<ul>
<li>如果是协议和端口造成的跨域问题“前台”是无能为力的。</li>
<li>在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。</li>
</ul>
<h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><ol>
<li>jsonp</li>
</ol>
<ul>
<li><p>原理：<br>利用\&lt;script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。</p>
</li>
<li><p>JSONP 和 AJAX 对比：<br>JSONP 和 AJAX 相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但 AJAX 属于同源策略，JSONP 属于非同源策略（跨域请求）</p>
</li>
<li><p>JSONP 优缺点：<br>JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。</p>
</li>
<li><p>JSONP 的实现流程：</p>
<ul>
<li>声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。</li>
<li>创建一个\&lt;script>标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。</li>
<li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show(‘我不爱你’)。</li>
<li>最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。</li>
</ul>
</li>
</ul>
<p>自己封装一个 JSONP 函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data);</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line">    params = &#123; ...params, callback &#125;; <span class="comment">// wd=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">'&amp;'</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:3000/say'</span>,</span><br><span class="line">  params: &#123; <span class="attr">wd</span>: <span class="string">'Iloveyou'</span> &#125;,</span><br><span class="line">  callback: <span class="string">'show'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码相当于向<a href="http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行show()这个函数，打印出&#39;我不爱你&#39;">http://localhost:3000/say?wd=Iloveyou&amp;callback=show这个地址请求数据，然后后台返回show(&#39;我不爱你&#39;)，最后会运行show()这个函数，打印出&#39;我不爱你&#39;</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.get(<span class="string">'/say'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; wd, callback &#125; = req.query;</span><br><span class="line">  <span class="built_in">console</span>.log(wd); <span class="comment">// Iloveyou</span></span><br><span class="line">  <span class="built_in">console</span>.log(callback); <span class="comment">// show</span></span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('我不爱你')`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>jQuery 的 jsonp 形式</li>
</ul>
<p>JSONP 都是 GET 和异步请求的，不存在其他的请求方式和同步请求，且 jQuery 默认就会给 JSONP 的请求清除缓存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">'http://crossdomain.com/jsonServerResponse'</span>,</span><br><span class="line">  dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">  type: <span class="string">'get'</span>, <span class="comment">//可以省略</span></span><br><span class="line">  jsonpCallback: <span class="string">'show'</span>, <span class="comment">//-&gt;自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略</span></span><br><span class="line">  jsonp: <span class="string">'callback'</span>, <span class="comment">//-&gt;把传递函数名的那个形参callback，可省略</span></span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>cors</li>
</ol>
<p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。</p>
<p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求</strong>和<strong>复杂请求</strong>。</p>
<ul>
<li><strong>简单请求</strong></li>
</ul>
<p>只要同时满足以下两大条件，就属于简单请求</p>
<p>条件 1：使用下列方法之一：</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<p>条件 2：Content-Type 的值仅限于下列三者之一：</p>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<ul>
<li><strong>复杂请求</strong></li>
</ul>
<p>不符合以上条件的请求就肯定是复杂请求了。<br>复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p>
<p>我们用 PUT 向后台请求时，属于复杂请求，后台需做如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>);</span><br><span class="line"><span class="comment">// 预检的存活时间</span></span><br><span class="line">res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">  res.end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义后台返回的内容</span></span><br><span class="line">app.put(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers);</span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一个完整复杂请求的例子，并且介绍下 CORS 请求相关的字段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=xiamen'</span>; <span class="comment">// cookie不能跨域</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>; <span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:4000/getData'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'name'</span>, <span class="string">'xiamen'</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">      <span class="comment">//得到响应头，后台需设置Access-Control-Expose-Headers</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.getResponseHeader(<span class="string">'name'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//server1.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//server2.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"><span class="keyword">let</span> whitList = [<span class="string">'http://localhost:3000'</span>]; <span class="comment">//设置白名单</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.headers.origin;</span><br><span class="line">  <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">    <span class="comment">// 设置哪个源可以访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, origin);</span><br><span class="line">    <span class="comment">// 允许携带哪个头访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'name'</span>);</span><br><span class="line">    <span class="comment">// 允许哪个方法访问我</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>);</span><br><span class="line">    <span class="comment">// 允许携带cookie</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Credentials'</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 预检的存活时间</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 允许返回的头</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Expose-Headers'</span>, <span class="string">'name'</span>);</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">      res.end(); <span class="comment">// OPTIONS请求不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">app.put(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers);</span><br><span class="line">  res.setHeader(<span class="string">'name'</span>, <span class="string">'jw'</span>); <span class="comment">//返回一个响应头，后台需设置</span></span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/getData'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.headers);</span><br><span class="line">  res.end(<span class="string">'我不爱你'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.use(express.static(__dirname));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>postMessage</li>
</ol>
<p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
<ol start="4">
<li>websocket</li>
</ol>
<p>Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<ol start="5">
<li>Node 中间件代理(两次跨域)</li>
</ol>
<p>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。<br>代理服务器，需要做以下几个步骤：</p>
<ul>
<li>接受客户端请求 。</li>
<li>将请求转发给服务器。</li>
<li>拿到服务器响应数据。</li>
<li>将响应转发给客户端。</li>
</ul>
<p>本地文件 index.html 文件，通过代理服务器<a href="http://localhost:3000向目标服务器http://localhost:4000请求数据。">http://localhost:3000向目标服务器http://localhost:4000请求数据。</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html(http://127.0.0.1:5500)</span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    data: &#123; <span class="attr">name</span>: <span class="string">'xiamen'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;,</span><br><span class="line">    contentType: <span class="string">'application/json;charset=utf-8'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(result) <span class="comment">// &#123;"title":"fontend","password":"123456"&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server1.js 代理服务器(http:/</span><span class="regexp">/localhost:3000)</span></span><br><span class="line"><span class="regexp">const http = require('http')</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第一步：接受客户端请求</span></span><br><span class="line"><span class="regexp">const server = http.createServer((request, response) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段</span></span><br><span class="line"><span class="regexp">  response.writeHead(200, &#123;</span></span><br><span class="line"><span class="regexp">    'Access-Control-Allow-Origin': '*',</span></span><br><span class="line"><span class="regexp">    'Access-Control-Allow-Methods': '*',</span></span><br><span class="line"><span class="regexp">    'Access-Control-Allow-Headers': 'Content-Type'</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 第二步：将请求转发给服务器</span></span><br><span class="line"><span class="regexp">  const proxyRequest = http</span></span><br><span class="line"><span class="regexp">    .request(</span></span><br><span class="line"><span class="regexp">      &#123;</span></span><br><span class="line"><span class="regexp">        host: '127.0.0.1',</span></span><br><span class="line"><span class="regexp">        port: 4000,</span></span><br><span class="line"><span class="regexp">        url: '/</span><span class="string">',</span></span><br><span class="line"><span class="string">        method: request.method,</span></span><br><span class="line"><span class="string">        headers: request.headers</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">      serverResponse =&gt; &#123;</span></span><br><span class="line"><span class="string">        // 第三步：收到服务器的响应</span></span><br><span class="line"><span class="string">        var body = '</span><span class="string">'</span></span><br><span class="line"><span class="string">        serverResponse.on('</span>data<span class="string">', chunk =&gt; &#123;</span></span><br><span class="line"><span class="string">          body += chunk</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">        serverResponse.on('</span>end<span class="string">', () =&gt; &#123;</span></span><br><span class="line"><span class="string">          console.log('</span>The data is <span class="string">' + body)</span></span><br><span class="line"><span class="string">          // 第四步：将响应结果转发给浏览器</span></span><br><span class="line"><span class="string">          response.end(body)</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">    .end()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">server.listen(3000, () =&gt; &#123;</span></span><br><span class="line"><span class="string">  console.log('</span>The proxyServer is running at http:<span class="comment">//localhost:3000')</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server2.js(http://localhost:4000)</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">title</span>: <span class="string">'fontend'</span>, <span class="attr">password</span>: <span class="string">'123456'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    response.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">4000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The server is running at http://localhost:4000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>nginx 反向代理</li>
</ol>
<p>实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。</p>
<p>使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。</p>
<p>实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<p>先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后通过命令行 nginx -s reload 启动 nginx</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>));</span><br><span class="line">  <span class="comment">// 向前台写cookie</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>, <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">  &#125;);</span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(params));</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-的数据类型及其检测"><a href="#JavaScript-的数据类型及其检测" class="headerlink" title="JavaScript 的数据类型及其检测"></a><div align=center>JavaScript 的数据类型及其检测</h3><hr>
<p><img src="前端基础汇总2/js数据类型.png" alt="js数据类型"></p>
<h4 id="JavaScript-有几种类型的值"><a href="#JavaScript-有几种类型的值" class="headerlink" title="JavaScript 有几种类型的值"></a>JavaScript 有几种类型的值</h4><p>Javascript 有两种数据类型，分别是基本数据类型和引用数据类型。其中基本数据类型包括 Undefined、Null、Boolean、Number、String、Symbol (ES6 新增，表示独一无二的值)，而引用数据类型统称为 Object 对象，主要包括对象、数组和函数。</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ol>
<li><p>值是不可变的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'java'</span>;</span><br><span class="line">name.toUpperCase(); <span class="comment">// 输出 'JAVA'</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出  'java'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存放在栈区<br>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p>
</li>
<li><p>值的比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>== : 只进行值的比较,会进行数据类型的转换。<br>=== : 不仅进行值得比较，还要进行数据类型的比较。</p>
</li>
</ol>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><ol>
<li><p>值是可变的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="attr">age</span>:<span class="number">20</span>&#125;；</span><br><span class="line">a.age=<span class="number">21</span>；</span><br><span class="line"><span class="built_in">console</span>.log(a.age)<span class="comment">//21</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时保存在栈内存和堆内存<br>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><img src="前端基础汇总2/引用类型.png" alt="引用类型"></p>
</li>
<li>比较是引用的比较<br>当从一个变量向另一个变量赋引用类型的值时，同样也会将存储在变量中的对象的值复制一份放到为新变量分配的空间中。</li>
</ol>
<h4 id="检验数据类型"><a href="#检验数据类型" class="headerlink" title="检验数据类型"></a>检验数据类型</h4><ol>
<li>typeof<br>typeof 返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、symbol、object、undefined、function 等 7 种数据类型，但不能判断 null、array 等</li>
<li><p>instanceof<br>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>instanceof 三大弊端：</p>
<ul>
<li><p>对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>只要在当前实例的原型链上，我们用其检测出来的结果都是 true。在类的原型继承中，我们最后检测出来的结果未必准确。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能检测 null 和 undefined</p>
</li>
</ul>
</li>
<li>constructor<br>constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。<br>constructor 两大弊端：<ul>
<li>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</li>
<li>函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的 constructor 给覆盖了，这样检测出来的结果就是不准确的</li>
</ul>
</li>
<li>Object.prototype.toString.call()<br>Object.prototype.toString.call() 最准确最常用的方式。首先获取 Object 原型上的 toString 方法，让方法执行，让 toString 方法中的 this 指向第一个参数的值。</li>
</ol>
<p>关于 toString 重要补充说明：</p>
<ul>
<li>本意是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串</li>
<li>对于 Number、String，Boolean，Array，RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）</li>
<li>Object 上的 toString 并不是用来转换为字符串的。</li>
</ul>
<h3 id="JavaScript-数据类型转换"><a href="#JavaScript-数据类型转换" class="headerlink" title="JavaScript 数据类型转换"></a><div align=center>JavaScript 数据类型转换</h3><hr>
<p>JavaScript 是一门动态语言，所谓的动态语言可以暂时理解为在语言中的一切内容都是不确定的。比如一个变量，这一时刻是个整型，下一时刻可能会变成字符串了。虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。</p>
<p>自动转换是基于强制转换之上的。强制转换主要指使用 Number、String 和 Boolean 三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><ol>
<li><p>其他的数据类型转换为 String<br>方式一：toString()方法</p>
<ul>
<li>调用被转换数据类型的 toString()方法,该方法不会影响到原变量，它会将转换的结果返回，但是注意：<strong>null 和 undefined 这两个值没有 toString，如果调用他们的方法，会报错</strong>。</li>
<li><p>采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">alert(iNum.toString(<span class="number">2</span>)); <span class="comment">//输出 "1010"</span></span><br><span class="line">alert(iNum.toString(<span class="number">8</span>)); <span class="comment">//输出 "12"</span></span><br><span class="line">alert(iNum.toString(<span class="number">16</span>)); <span class="comment">//输出 "A"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>方式二：String()函数</p>
<ul>
<li>使用 String()函数做强制类型转换时，对于 Number 和 Boolean 实际上就是调用的 toString()方法,但是对于 null 和 undefined，就不会调用 toString()方法,它会将 null 直接转换为”null”,将 undefined 直接转换为”undefined”</li>
<li>String 方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</li>
</ul>
</li>
<li><p>其他的数据类型转换为 Number<br>方式一：使用 Number()函数</p>
<ul>
<li>原始类型值<ul>
<li>字符串转数字<ul>
<li>如果是纯数字的字符串，则直接将其转换为数字</li>
<li>如果字符串中有非数字的内容，则转换为 NaN</li>
<li>如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0</li>
</ul>
</li>
<li>布尔值转数字:true 转成 1,false 转成 0</li>
<li>undefined 转数字:转成 NaN</li>
<li>null 转数字：转成 0</li>
<li>Number() 接受数值作为参数，此时它既能识别负的十六进制，也能识别 0 开头的八进制，返回值永远是十进制值</li>
</ul>
</li>
<li>对象<br>简单的规则是，Number 方法的参数是对象时，将返回 NaN，除非是包含单个数值的数组。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">5</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>方式二：parseInt() &amp; parseFloat()<br>这种方式专门用来对付字符串，parseInt()一个字符串转换为一个整数,可以将一个字符串中的有效的整数内容取出来，然后转换为 Number。parseFloat()把一个字符串转换为一个浮点数。parseFloat()作用和 parseInt()类似，不同的是它可以获得有效的小数。<br>parseInt()在没有第二个参数时默认以十进制转换数值，有第二个参数时，以第二个参数为基数转换数值，如果基数有误返回 NaN</p>
<p><strong>两者的区别：Number 函数将字符串转为数值，要比 parseInt 函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为 NaN。</strong></p>
</li>
<li><p>其他的数据类型转换为 Boolean<br>它的转换规则相对简单：只有空字符串(“”)、null、undefined、+0、-0 和 NaN 转为布尔型是 false，其他的都是 true</p>
</li>
</ol>
<h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。</p>
<ol>
<li>自动转换为布尔值<br>JavaScript 遇到预期为布尔值的地方(比如 if 语句的条件部分),就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用 Boolean 函数。</li>
<li>自动转换为数值<br>算数运算符(+ - * /)跟非 Number 类型的值进行运算时，会将这些值转换为 Number，然后在运算，除了字符串的加法运算</li>
<li>自动转换为字符串<br>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</li>
</ol>
<h3 id="深入理解-JavaScript-作用域和作用域链"><a href="#深入理解-JavaScript-作用域和作用域链" class="headerlink" title="深入理解 JavaScript 作用域和作用域链"></a><div align=center>深入理解 JavaScript 作用域和作用域链</h3><hr>
<h4 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h4><ol>
<li>什么是作用域<br>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。(作用域（scope）指的是变量存在的范围。)<br>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。</li>
<li><p>全局作用域和函数作用域</p>
<ul>
<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
</li>
</ol>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p>
<p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。<br>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</p>
<p><strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 'if' 条件语句块不会创建一个新的作用域</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Hammad'</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs 'Hammad'</span></span><br></pre></td></tr></table></figure>
<p>会发生变量提升。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p>
<ol start="3">
<li><p>块级作用域<br>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
</li>
</ol>
<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>
<ul>
<li>声明变量不会提升到代码块顶部</li>
<li>禁止重复声明</li>
<li>循环中的绑定块作用域的妙用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><ol>
<li><p>什么是自由变量<br>首先认识一下什么叫做 自由变量 。如下代码中，console.log(a)要得到 a 变量，但是在当前的作用域中没有定义 a（可对比一下 b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 这里的a在这里就是一个自由变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是作用域链<br>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 自由变量，顺作用域链向父作用域找</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 自由变量，顺作用域链向父作用域找</span></span><br><span class="line">    <span class="built_in">console</span>.log(c); <span class="comment">// 本作用域的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  F2();</span><br><span class="line">&#125;</span><br><span class="line">F1();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于自由变量的取值<br>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    f(); <span class="comment">//10，而不是20</span></span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">show(fn);</span><br></pre></td></tr></table></figure>
<p>要到创建这个函数的那个域”。<br>作用域中取值,这里强调的是“创建”，而不是“调用”，切记切记——其实这就是所谓的”静态作用域”</p>
</li>
</ol>
<h4 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h4><p>我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p>
<p>解释阶段：</p>
<ul>
<li>词法分析</li>
<li>语法分析</li>
<li>作用域规则确定</li>
</ul>
<p>执行阶段：</p>
<ul>
<li>创建执行上下文</li>
<li>执行函数代码</li>
<li>垃圾回收</li>
</ul>
<p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p>
<p>作用域和执行上下文之间最大的区别是：<br><strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。</strong></p>
<h3 id="JavaScript-执行上下文和执行栈"><a href="#JavaScript-执行上下文和执行栈" class="headerlink" title="JavaScript 执行上下文和执行栈"></a><div align=center>JavaScript 执行上下文和执行栈</h3><hr>
<h4 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h4><ol>
<li>什么是执行上下文<br>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行</li>
<li>执行上下文的类型<br>执行上下文总共有三种类型：<ul>
<li>全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>
<li>函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤</li>
<li>Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</li>
</ul>
</li>
</ol>
<h4 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h4><p>执行上下文的生命周期包括三个阶段：<strong>创建阶段 → 执行阶段 → 回收阶段</strong></p>
<ol>
<li>创建阶段<br>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：<ul>
<li>创建变量对象：首先初始化函数的参数 arguments，提升函数声明和变量声明。</li>
<li>创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。</li>
<li>确定 this 指向：包括多种情况</li>
</ul>
</li>
</ol>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为 undefined，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过 函数执行上下文中会多出 this arguments 和函数的参数。</p>
<ol start="2">
<li><p>执行阶段<br>执行变量赋值、代码执行</p>
</li>
<li><p>回收阶段<br>执行上下文出栈等待虚拟机回收执行上下文</p>
</li>
</ol>
<h4 id="变量提升和-this-指向的细节"><a href="#变量提升和-this-指向的细节" class="headerlink" title="变量提升和 this 指向的细节"></a>变量提升和 this 指向的细节</h4><ol>
<li><p>变量声明提升<br>大部分编程语言都是先声明变量再使用，但在 JS 中，事情有些不一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">//声明 默认值是undefined “准备工作”</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">10</span>; <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明提升<br>创建一个函数的方法有两种，一种是通过函数声明 function foo(){}<br>另一种是通过函数表达式 var foo = function(){}</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f1); <span class="comment">// function f1()&#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 函数声明</span></span><br><span class="line"><span class="built_in">console</span>.log(f2); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 函数表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(); <span class="comment">// Uncaught TypeError "foo is not a function"</span></span><br><span class="line">  bar(); <span class="comment">// "this will run!"</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// function expression assigned to local variable 'foo'</span></span><br><span class="line">    alert(<span class="string">"this won't run!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// function declaration, given the name 'bar'</span></span><br><span class="line">    alert(<span class="string">'this will run!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>遇到函数表达式 var foo = function(){}时，首先会将 var foo 上升到函数体顶部，然而此时的 foo 的值为 undefined,所以执行 foo()报错。<br>当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">alert(a); <span class="comment">//输出：function a()&#123; alert('我是函数') &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'我是函数'</span>);</span><br><span class="line">&#125; <span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'我是变量'</span>;</span><br><span class="line">alert(a); <span class="comment">//输出：'我是变量'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个复杂的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 形参 arg 是 "hi"</span></span><br><span class="line">  <span class="comment">// 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 function</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">  <span class="keyword">var</span> arg = <span class="string">'hello'</span>; <span class="comment">// 3.var arg 变量声明被忽略， arg = 'hello'被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">arg</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'hi'</span>);</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"> function arg()&#123;</span></span><br><span class="line"><span class="comment">     console.log('hello world') </span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment"> hello </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：</p>
<ul>
<li>如果有形参，先给形参赋值</li>
<li>进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值</li>
<li>私有作用域中的代码从上到下执行</li>
</ul>
</li>
<li><p>确定 this 的指向<br><strong>this 的值是在执行的时候才能确认，定义的时候不能确认</strong><br>因为 this 是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">fn</span>: fn &#125;;</span><br><span class="line">obj.fn(); <span class="comment">//this-&gt;obj</span></span><br></pre></td></tr></table></figure>
<p>对于 obj.fn() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 fn 函数中的 this 就是 obj 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateJsPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//this是当前类的一个实例p1</span></span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">//=&gt;p1.name=name</span></span><br><span class="line">  <span class="keyword">this</span>.age = age; <span class="comment">//=&gt;p1.age=age</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> CreateJsPerson(<span class="string">'尹华芝'</span>, <span class="number">48</span>);</span><br></pre></td></tr></table></figure>
<p>在构造函数模式中，类中(函数体中)出现的 this.xxx=xxx 中的 this 是当前类的一个实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br></pre></td></tr></table></figure>
<p>call、apply 和 bind：this 是第一个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况5</span></span><br><span class="line">&lt;button id=<span class="string">"btn1"</span>&gt;箭头函数<span class="keyword">this</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    let btn1 = document.getElementById('btn1');</span></span><br><span class="line"><span class="string">    let obj = &#123;</span></span><br><span class="line"><span class="string">        name: 'kobe',</span></span><br><span class="line"><span class="string">        age: 39,</span></span><br><span class="line"><span class="string">        getName: function () &#123;</span></span><br><span class="line"><span class="string">            btn1.onclick = () =&gt; &#123;</span></span><br><span class="line"><span class="string">                console.log(this);//obj</span></span><br><span class="line"><span class="string">            &#125;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    obj.getName();</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>箭头函数 this 指向:箭头函数没有自己的 this，看其外层的是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window。</p>
</li>
</ol>
<h4 id="执行上下文栈（Execution-Context-Stack）"><a href="#执行上下文栈（Execution-Context-Stack）" class="headerlink" title="执行上下文栈（Execution Context Stack）"></a>执行上下文栈（Execution Context Stack）</h4><p>JavaScript 引擎创建了执行上下文栈来管理执行上下文。可以把执行上下文栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。<br><img src="前端基础汇总2/执行栈.gif" alt="执行栈"></p>
<ul>
<li>JavaScript 执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
</ul>
<h3 id="JavaScript-运行机制"><a href="#JavaScript-运行机制" class="headerlink" title="JavaScript 运行机制"></a><div align=center>JavaScript 运行机制</h3><hr>
<h4 id="理解-JS-的单线程的概念"><a href="#理解-JS-的单线程的概念" class="headerlink" title="理解 JS 的单线程的概念"></a>理解 JS 的单线程的概念</h4><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢？这样能提高效率啊。<br>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<h4 id="理解任务队列-消息队列"><a href="#理解任务队列-消息队列" class="headerlink" title="理解任务队列(消息队列)"></a>理解任务队列(消息队列)</h4><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>JavaScript 语言的设计者意识到这个问题，将所有任务分成两种，<strong>一种是同步任务（synchronous），另一种是异步任务（asynchronous）</strong>。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br><strong>异步任务包括宏任务和微任务</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line"><span class="comment">//请问最后的输出结果是什么？——A</span></span><br><span class="line"><span class="comment">//因为这是同步任务，程序由上到下执行，遇到while()死循环，下面语句就没办法执行。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"><span class="comment">//请问最后的输出结果是什么？——A</span></span><br><span class="line"><span class="comment">//在所有同步任务执行完之前，任何的异步任务是不会执行的</span></span><br></pre></td></tr></table></figure>
<h4 id="理解-Event-Loop"><a href="#理解-Event-Loop" class="headerlink" title="理解 Event Loop"></a>理解 Event Loop</h4><p>异步执行的运行机制如下：</p>
<ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ul>
<p><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</strong>。只要主线程空了，就会去读取”任务队列”，这就是 JavaScript 的运行机制。这个过程会循环反复。<br><img src="前端基础汇总2/事件循环.png" alt="eventLoop"></p>
<h4 id="哪些语句会放入异步任务队列及放入时机"><a href="#哪些语句会放入异步任务队列及放入时机" class="headerlink" title="哪些语句会放入异步任务队列及放入时机"></a>哪些语句会放入异步任务队列及放入时机</h4><p>一般来说，有以下四种会放入异步任务队列</p>
<ul>
<li>setTimeout 和 setlnterval</li>
<li>DOM 事件</li>
<li>ES6 中的 Promise</li>
<li>Ajax 异步请求</li>
</ul>
<p>javascript 代码运行分两个阶段：<br>1、预解析—把所有的函数定义提前，所有的变量声明提前，变量的赋值不提前</p>
<p>2、执行—从上到下执行（按照 js 运行机制）</p>
<p>至于放入异步任务队列的时机，我们通过 setTimeout 的例子和 Ajax 例子来详细说明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环一次碰到一个 setTimeout()，<strong>并不是马上把 setTimeout()拿到异步队列中，而要等到一秒后，才将其放到任务队列里面</strong>，一旦”执行栈”中的所有同步任务执行完毕（即 for 循环结束，此时 i 已经为 5），系统就会读取已经存放”任务队列”的 setTimeout()（有五个），于是答案是输出 5 个 5。</p>
<h4 id="微任务-Microtask-与宏任务-Macrotask"><a href="#微任务-Microtask-与宏任务-Macrotask" class="headerlink" title="微任务(Microtask)与宏任务(Macrotask)"></a>微任务(Microtask)与宏任务(Macrotask)</h4><p>宏任务队列可以有多个，微任务队列只有一个。</p>
<ul>
<li>宏任务包括：script(全局任务), setTimeout, setInterval, setImmediate, I/O, UI rendering。</li>
<li>微任务包括: new Promise().then(回调), process.nextTick, Object.observe(已废弃), MutationObserver(html5 新特性)</li>
</ul>
<p><strong>当执行栈中的所有同步任务执行完毕时，是先执行宏任务还是微任务呢</strong>？</p>
<ul>
<li>由于执行代码入口都是全局任务 script，而全局任务属于宏任务，所以当栈为空，同步任务任务执行完毕时，会先执行微任务队列里的任务。</li>
<li>微任务队列里的任务全部执行完毕后，会读取宏任务队列中拍最前的任务。</li>
<li>执行宏任务的过程中，遇到微任务，依次加入微任务队列。</li>
<li>栈空后，再次读取微任务队列里的任务，依次类推。</li>
</ul>
<p><strong>当某个宏任务队列的中的任务全部执行完以后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，就查看是否有其他宏任务队列。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果是Promise1，setTimeout1，Promise2，setTimeout2</span></span><br></pre></td></tr></table></figure>
<h3 id="数组常用遍历的方法"><a href="#数组常用遍历的方法" class="headerlink" title="数组常用遍历的方法"></a><div align=center>数组常用遍历的方法</h3><hr>
<p>介绍数组常见遍历方法：forEach、map、filter、find、every、some、reduce，它们有个共同点：不会改变原始数组。</p>
<h4 id="forEach：遍历数组"><a href="#forEach：遍历数组" class="headerlink" title="forEach：遍历数组"></a>forEach：遍历数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">numbers.forEach(<span class="function"><span class="params">number</span> =&gt;</span> (sum += number));</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<h4 id="map：将数组映射成另一个数组"><a href="#map：将数组映射成另一个数组" class="headerlink" title="map：将数组映射成另一个数组"></a>map：将数组映射成另一个数组</h4><p>map 通过指定函数处理数组的每个元素，并返回处理后新的数组，map 不会改变原始数组。<br>forEach 和 map 的区别在于，forEach 没有返回值。<br>map 需要返回值，如果不给 return，默认返回 undefined</p>
<ol>
<li><p>场景 1<br>假定有一个数值数组(A),将 A 数组中的值以双倍的形式放到 B 数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 map方法</span></span><br><span class="line"><span class="keyword">var</span> doubled = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(doubled); <span class="comment">//[2,4,6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>场景 2<br>假定有一个对象数组(A),将 A 数中对象某个属性的值存储到 B 数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars = [</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">'Buick'</span>, <span class="attr">price</span>: <span class="string">'CHEAP'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">model</span>: <span class="string">'BMW'</span>, <span class="attr">price</span>: <span class="string">'expensive'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> prices = cars.map(<span class="function"><span class="keyword">function</span>(<span class="params">car</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> car.price;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(prices); <span class="comment">//["CHEAP", "expensive"]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="filter：从数组中找出所有符合指定条件的元素"><a href="#filter：从数组中找出所有符合指定条件的元素" class="headerlink" title="filter：从数组中找出所有符合指定条件的元素"></a>filter：从数组中找出所有符合指定条件的元素</h3><p>filter() 检测数组元素，并返回符合条件所有元素的数组。 filter() 不会改变原始数组。</p>
<ol>
<li><p>场景 1<br>假定有一个对象数组(A),获取数组中指定类型的对象放到 B 数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 filter</span></span><br><span class="line"><span class="keyword">var</span> filtered2 = porducts.filter(<span class="function"><span class="keyword">function</span>(<span class="params">product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> product.type === <span class="string">'vegetable'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(filtered2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景 2<br>假定有一个对象数组(A),过滤掉不满足条件的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> products = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'cucumber'</span>, <span class="attr">type</span>: <span class="string">'vegetable'</span>, <span class="attr">quantity</span>: <span class="number">0</span>, <span class="attr">price</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'banana'</span>, <span class="attr">type</span>: <span class="string">'fruit'</span>, <span class="attr">quantity</span>: <span class="number">10</span>, <span class="attr">price</span>: <span class="number">16</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'celery'</span>, <span class="attr">type</span>: <span class="string">'vegetable'</span>, <span class="attr">quantity</span>: <span class="number">30</span>, <span class="attr">price</span>: <span class="number">8</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'orange'</span>, <span class="attr">type</span>: <span class="string">'fruit'</span>, <span class="attr">quantity</span>: <span class="number">3</span>, <span class="attr">price</span>: <span class="number">6</span> &#125;,</span><br><span class="line">];</span><br><span class="line">products = products.filter(<span class="function"><span class="keyword">function</span>(<span class="params">product</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    product.type === <span class="string">'vegetable'</span> &amp;&amp;</span><br><span class="line">    product.quantity &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    product.price &lt; <span class="number">10</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(products); <span class="comment">//[&#123;name:"celery",type:"vegetable",quantity:30,price:8&#125;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>场景 3<br>假定有两个数组(A,B),根据 A 中 id 值,过滤掉 B 数组不符合的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> post = &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">title</span>: <span class="string">'Javascript'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> comments = [</span><br><span class="line">  &#123; <span class="attr">postId</span>: <span class="number">4</span>, <span class="attr">content</span>: <span class="string">'Angular4'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">postId</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">'Vue.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">postId</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">postId</span>: <span class="number">4</span>, <span class="attr">content</span>: <span class="string">'React.js'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commentsForPost</span>(<span class="params">post, comments</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> comments.filter(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comment.postId === post.id;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(commentsForPost(post, comments)); <span class="comment">//[&#123;postId:4,content:"Angular4"&#125;,&#123;postId:4,content</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="find：返回通过测试（函数内判断）的数组的第一个元素的值"><a href="#find：返回通过测试（函数内判断）的数组的第一个元素的值" class="headerlink" title="find：返回通过测试（函数内判断）的数组的第一个元素的值"></a>find：返回通过测试（函数内判断）的数组的第一个元素的值</h4><p>它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</p>
<ol>
<li><p>场景 1<br>假定有一个对象数组(A),找到符合条件的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 find</span></span><br><span class="line">user = users.find(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.name === <span class="string">'Alex'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(user); <span class="comment">// &#123;name:"Alex",id:2&#125;找到后就终止循环</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>场景 2<br>假定有一个对象数组(A),根据指定对象的条件找到数组中符合条件的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> posts = [&#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">'Node.js'</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'React.js'</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> comment = &#123; <span class="attr">postId</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">'Hello World!'</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postForComment</span>(<span class="params">posts, comment</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> posts.find(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> post.id === comment.postId;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(postForComment(posts, comment)); <span class="comment">//&#123;id: 1, title: "React.js"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="every-amp-some"><a href="#every-amp-some" class="headerlink" title="every&amp;some"></a>every&amp;some</h4><p>every：数组中是否每个元素都满足指定的条件</p>
<p>some: 数组中是否有元素满足指定的条件</p>
<p>一言以蔽之：<strong>Some: 一真即真；Every: 一假即假</strong></p>
<ol>
<li><p>场景 1<br>计算对象数组中每个电脑操作系统是否可用，大于 16 位操作系统表示可用,否则不可用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6 some every</span></span><br><span class="line"><span class="keyword">var</span> every = computers.every(<span class="function"><span class="keyword">function</span>(<span class="params">computer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computer.ram &gt; <span class="number">16</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(every); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> some = computers.some(<span class="function"><span class="keyword">function</span>(<span class="params">computer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> computer.ram &gt; <span class="number">16</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(some); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>假定有一个注册页面,判断所有 input 内容的长度是否大于 0</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Field</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line">Field.prototype.validate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//ES5方法</span></span><br><span class="line"><span class="keyword">var</span> username = <span class="keyword">new</span> Field(<span class="string">'henrywu'</span>);</span><br><span class="line"><span class="keyword">var</span> telephone = <span class="keyword">new</span> Field(<span class="string">'18888888888'</span>);</span><br><span class="line"><span class="keyword">var</span> password = <span class="keyword">new</span> Field(<span class="string">'my_password'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(username.validate()); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(telephone.validate()); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(password.validate()); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//ES6 some every</span></span><br><span class="line"><span class="keyword">var</span> fields = [username, telephone, password];</span><br><span class="line"><span class="keyword">var</span> formIsValid = fields.every(<span class="function"><span class="keyword">function</span>(<span class="params">field</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> field.validate();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(formIsValid); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">if</span> (formIsValid) &#123;</span><br><span class="line">  <span class="comment">// 注册成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 给用户一个友善的错误提醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="reduce：将数组合成一个值"><a href="#reduce：将数组合成一个值" class="headerlink" title="reduce：将数组合成一个值"></a>reduce：将数组合成一个值</h4><p>reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。</p>
<ol>
<li><p>场景 1<br>计算数组中所有值的总和</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 reduce</span></span><br><span class="line"><span class="keyword">var</span> sumValue = numbers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sum2, number2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(sum2); <span class="comment">//0 10 30 60</span></span><br><span class="line">  <span class="keyword">return</span> sum2 + number2;</span><br><span class="line">&#125;, <span class="number">0</span>); <span class="comment">//sum2初始值为0</span></span><br><span class="line"><span class="built_in">console</span>.log(sumValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景 2<br>将数组中对象的某个属性抽离到另外一个数组中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> primaryColors = [</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">'yellow'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">'blue'</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> colors = primaryColors.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous, primaryColor</span>) </span>&#123;</span><br><span class="line">  previous.push(primaryColor.color);</span><br><span class="line">  <span class="keyword">return</span> previous;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="built_in">console</span>.log(colors); <span class="comment">//["red", "yellow", "blue"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>场景 3<br>判断字符串中括号是否对称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">balancedParens</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !string.split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous, char</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (previous &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (char == <span class="string">'('</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ++previous;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (char == <span class="string">')'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> --previous;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(balancedParens(<span class="string">'((())))'</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title=" 浅拷贝与深拷贝"></a><div align=center> 浅拷贝与深拷贝</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。</p>
<ul>
<li>基本数据类型的特点：直接存储在栈(stack)中的数据</li>
<li>引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里</li>
</ul>
<h4 id="浅拷贝与深拷贝-1"><a href="#浅拷贝与深拷贝-1" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h4><p>深拷贝和浅拷贝是只针对 Object 和 Array 这样的引用数据类型的。<br>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
<h4 id="赋值和浅拷贝的区别"><a href="#赋值和浅拷贝的区别" class="headerlink" title="赋值和浅拷贝的区别"></a>赋值和浅拷贝的区别</h4><ul>
<li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>
<li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象赋值</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'zhangsan'</span>,</span><br><span class="line">  age: <span class="string">'18'</span>,</span><br><span class="line">  language: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">'lisi'</span>;</span><br><span class="line">obj2.language[<span class="number">1</span>] = [<span class="string">'二'</span>, <span class="string">'三'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>, obj1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>, obj2);</span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/赋值.png" alt="赋值结果"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'zhangsan'</span>,</span><br><span class="line">  age: <span class="string">'18'</span>,</span><br><span class="line">  language: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3 = shallowCopy(obj1);</span><br><span class="line">obj3.name = <span class="string">'lisi'</span>;</span><br><span class="line">obj3.language[<span class="number">1</span>] = [<span class="string">'二'</span>, <span class="string">'三'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> dst = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> src) &#123;</span><br><span class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class="line">      dst[prop] = src[prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>, obj1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj3'</span>, obj3);</span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/浅拷贝结果.png" alt="浅拷贝结果"></p>
<h4 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h4><ol>
<li><p>Object.assign()<br>把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">a</span>: <span class="string">'kobe'</span>, <span class="attr">b</span>: <span class="number">39</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> initalObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">initalObj.a.a = <span class="string">'wade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a.a); <span class="comment">//wade</span></span><br></pre></td></tr></table></figure>
<p><strong>当 object 只有一层的时候，是深拷贝</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  username: <span class="string">'kobe'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.username = <span class="string">'wade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//&#123;username: "kobe"&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.prototype.concat()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    username: <span class="string">'kobe'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();</span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">'wade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//修改新对象会改到原对象:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Array.prototype.slice()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    username: <span class="string">' kobe'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line">arr3[<span class="number">2</span>].username = <span class="string">'wade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//修改新对象会改到原对象:</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Array 的 slice 和 concat 方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p>
<ul>
<li>如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li>
<li>对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li>
</ul>
<h4 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h4><ol>
<li>JSON.parse(JSON.stringify())<br><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</strong></li>
<li><p>手写递归方法<br>原理：<strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义检测数据类型的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkedType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target).slice(<span class="number">8</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现深度克隆---对象/数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断拷贝的数据类型</span></span><br><span class="line">  <span class="comment">//初始化变量result 成为最终克隆的数据</span></span><br><span class="line">  <span class="keyword">let</span> result,</span><br><span class="line">    targetType = checkedType(target);</span><br><span class="line">  <span class="keyword">if</span> (targetType === <span class="string">'Object'</span>) &#123;</span><br><span class="line">    result = &#123;&#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType === <span class="string">'Array'</span>) &#123;</span><br><span class="line">    result = [];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//遍历目标数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="comment">//获取遍历数据结构的每一项值。</span></span><br><span class="line">    <span class="keyword">let</span> value = target[i];</span><br><span class="line">    <span class="comment">//判断目标结构里的每一值是否存在对象/数组</span></span><br><span class="line">    <span class="keyword">if</span> (checkedType(value) === <span class="string">'Object'</span> || checkedType(value) === <span class="string">'Array'</span>) &#123;</span><br><span class="line">      <span class="comment">//对象/数组里嵌套了对象/数组</span></span><br><span class="line">      <span class="comment">//继续遍历获取到value值</span></span><br><span class="line">      result[i] = clone(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取到value值是基本的数据类型或者是函数。</span></span><br><span class="line">      result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数库 lodash</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Javascript-闭包"><a href="#Javascript-闭包" class="headerlink" title=" Javascript 闭包"></a><div align=center> Javascript 闭包</h3><p><img src="前端基础汇总2/闭包.png" alt="闭包"></p>
<h4 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2; <span class="comment">// f1返回了f2的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1(); <span class="comment">// result就是f2函数了</span></span><br><span class="line">result(); <span class="comment">// 执行result，全局作用域下没有a的定义，</span></span><br><span class="line"><span class="comment">//但是函数闭包，能够把定义函数的时候的作用域一起记住，输出999</span></span><br></pre></td></tr></table></figure>
<p><strong>定义在一个函数内部的函数</strong><br>闭包最大的特点，就是它可以“记住”诞生的环境，比如 f2 记住了它诞生的环境 f1，所以从 f2 可以得到 f1 的内部变量。</p>
<p>闭包形成的条件：</p>
<ul>
<li>函数嵌套</li>
<li>内部函数引用外部函数的局部变量</li>
</ul>
<h4 id="闭包的特性"><a href="#闭包的特性" class="headerlink" title="闭包的特性"></a>闭包的特性</h4><p>每个函数都是闭包，每个函数天生都能够记忆自己定义时所处的作用域环境。把一个函数从它定义的那个作用域，挪走，运行。这个函数居然能够记忆住定义时的那个作用域。不管函数走到哪里，定义时的作用域就带到了哪里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="keyword">var</span> inner;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">250</span>;</span><br><span class="line">  inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(a); <span class="comment">//这个函数虽然在外面执行，但能够记忆住定义时的那个作用域，a是250</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">300</span>;</span><br><span class="line">inner(); <span class="comment">//一个函数在执行的时候，找闭包里面的变量，不会理会当前作用域。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例题2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inn = outer(<span class="number">3</span>); <span class="comment">//数字3传入outer函数后，inner函数中x便会记住这个值</span></span><br><span class="line">inn(<span class="number">5</span>); <span class="comment">//当inner函数再传入5的时候，只会对y赋值，所以最后弹出8</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包的内存泄漏"><a href="#闭包的内存泄漏" class="headerlink" title="闭包的内存泄漏"></a>闭包的内存泄漏</h4><p>栈内存提供一个执行环境，即作用域，包括全局作用域和私有作用域,那他们什么时候释放内存的</p>
<ul>
<li>全局作用域—-只有当页面关闭的时候全局作用域才会销毁</li>
<li>私有的作用域—-只有函数执行才会产生</li>
</ul>
<p><strong>一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域中的代码执行完成后，我们当前作用域都会主动的进行释放和销毁。但当遇到函数执行返回了一个引用数据类型的值，并且在函数的外面被一个其他的东西给接收了，这种情况下一般形成的私有作用域都不会销毁。</strong><br>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(); <span class="comment">//fn执行形成的这个私有的作用域就不能再销毁了</span></span><br></pre></td></tr></table></figure>
<p>fn 函数内部的私有作用域会被一直占用的，发生了内存泄漏。<strong>所谓内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向 null。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>; <span class="comment">//内部变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过return返回add函数，就可以在outer函数外访问了</span></span><br><span class="line">    num++; <span class="comment">//内部函数有引用，作为add函数的一部分了</span></span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = outer();</span><br><span class="line">func1(); <span class="comment">//实际上是调用add函数， 输出1</span></span><br><span class="line">func1(); <span class="comment">//输出2 因为outer函数内部的私有作用域会一直被占用</span></span><br><span class="line"><span class="keyword">var</span> func2 = outer();</span><br><span class="line">func2(); <span class="comment">// 输出1  每次重新引用函数的时候，闭包是全新的。</span></span><br><span class="line">func2(); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>
<h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4><ol>
<li>可以读取函数内部的变量。</li>
<li>可以使变量的值长期保存在内存中，生命周期比较长。因此不能滥用闭包，否则会造成网页的性能问题。</li>
<li><p>可以用来实现 JS 模块。<br>JS 模块:具有特定功能的 js 文件,将所有的数据和功能都封装在一个函数内部(私有的),只向外暴露一个包信 n 个方法的对象或函数,模块的使用者,只需要通过模块暴露的对象调用方法来实现对应的功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.html文件</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"myModule.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  myModule2.doSomething()</span><br><span class="line">  myModule2.doOtherthing()</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/myModule.js文件</span></span><br><span class="line"><span class="regexp">(function () &#123;</span></span><br><span class="line"><span class="regexp">  var msg = 'Beijing'/</span><span class="regexp">/私有数据</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/操作数据的函数</span></span><br><span class="line"><span class="regexp">  function doSomething() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('doSomething() '+msg.toUpperCase())</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  function doOtherthing () &#123;</span></span><br><span class="line"><span class="regexp">    console.log('doOtherthing() '+msg.toLowerCase())</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/向外暴露对象(给外部使用的两个方法)</span></span><br><span class="line"><span class="regexp">  window.myModule2 = &#123;</span></span><br><span class="line"><span class="regexp">    doSomething: doSomething,</span></span><br><span class="line"><span class="regexp">    doOtherthing: doOtherthing</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)()</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="闭包的运用"><a href="#闭包的运用" class="headerlink" title="闭包的运用"></a>闭包的运用</h4><p>点击某个按钮, 提示”点击的是第 n 个按钮”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（闭包实现）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    btn[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(j);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  btn[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="搞懂-This"><a href="#搞懂-This" class="headerlink" title=" 搞懂 This"></a><div align=center> 搞懂 This</h3><p>this 关键字是 JavaScript 中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。<br><img src="前端基础汇总2/this.png" alt="this"></p>
<h4 id="了解-this"><a href="#了解-this" class="headerlink" title="了解 this"></a>了解 this</h4><p><strong>this 既不指向函数自身也不指向函数的词法作用域</strong><br>JS 中的 this 代表的是当前行为执行的主体，在 JS 中主要研究的都是函数中的 this，但并不是说只有在函数里才有 this，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>
<h4 id="this-到底是谁"><a href="#this-到底是谁" class="headerlink" title="this 到底是谁"></a>this 到底是谁</h4><ol>
<li>函数执行时首先看函数名前面是否有”.”，有的话，”.”前面是谁,this 就是谁；没有的话 this 就是 window</li>
<li>自执行函数中的 this 永远是 window</li>
<li><p>给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的 this 是当前的元素，除了 IE6~8 下使用 attachEvent（IE 一个著名的 bug）</p>
<ul>
<li><p>DOM 零级事件绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DOM 二级事件绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oDiv.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this-&gt;oDiv</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 IE6~8 下使用 attachEvent，默认的 this 就是指的 window 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oDiv.attachEvent(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//this-&gt;window</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在构造函数模式中，类中(函数体中)出现的 this.xxx=xxx 中的 this 是当前类的一个实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateJsPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//浏览器默认创建的对象就是我们的实例p1-&gt;this</span></span><br><span class="line"><span class="keyword">this</span>.name=name;<span class="comment">//-&gt;p1.name=name</span></span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line"><span class="keyword">this</span>.writeJs=<span class="function"><span class="keyword">function</span>（）</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"my name is"</span>+<span class="keyword">this</span>.name +<span class="string">",i can write Js"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">//浏览器再把创建的实例默认的进行返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> CreateJsPerson(<span class="string">"尹华芝"</span>,<span class="number">48</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>call、apply 和 bind<br>一个问题，想在下面的例子中 this 绑定 obj,怎么实现？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'浪里行舟'</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//this=&gt;window</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">obj.fn(); <span class="comment">//-&gt;Uncaught TypeError:obj.fn is not a function</span></span><br></pre></td></tr></table></figure>
<p>这里我们应该用 fn.call(obj)就可以实现 this 绑定 obj</p>
<ul>
<li><p>call 方法的作用:</p>
<ul>
<li>首先我们让原型上的 call 方法执行，在执行 call 方法的时候，我们让 fn 方法中的 this 变为第一个参数值 obj；然后再把 fn 这个函数执行。</li>
<li><p>call 还可以传值，在严格模式下和非严格模式下，得到值不一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在非严格模式下</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">'浪里行舟 '</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1 + num2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="number">100</span>, <span class="number">200</span>); <span class="comment">//this-&gt;100 num1=200 num2=undefined</span></span><br><span class="line">fn.call(obj, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">//this-&gt;obj num1=100 num2=200</span></span><br><span class="line">fn.call(); <span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">null</span>); <span class="comment">//this-&gt;window</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>); <span class="comment">//this-&gt;window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//严格模式下</span></span><br><span class="line">fn.call(); <span class="comment">//在严格模式下this-&gt;undefined</span></span><br><span class="line">fn.call(<span class="literal">null</span>); <span class="comment">// 在严格模式 下this-&gt;null</span></span><br><span class="line">fn.call(<span class="literal">undefined</span>); <span class="comment">//在严格模式下this-&gt;undefined</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>apply 和 call 方法的作用是一模一样的，都是用来改变方法的 this 关键字并且把方法<br>执行，而且在严格模式下和非严格模式下对于第一个参数是 null/undefined 这种情况的规律也是一样的。<br>两者唯一的区别：call 在给 fn 传递参数的时候，是一个个的传递值的，而 apply 不是一个个传，而是把要给 fn 传递的参数值统一的放在一个数组中进行操作。但是也相当于一个个的给 fn 的形参赋值。总结一句话:call 第二个参数开始接受一个参数列表,apply 第二个参数开始接受一个参数数组</p>
</li>
<li><p>bind：这个方法在 IE6 ～ 8 下不兼容，和 call/apply 类似都是用来改变 this 关键字的，但是和这两者有明显区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//-&gt;改变this和执行fn函数是一起都完成了</span></span><br><span class="line">fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//-&gt;只是改变了fn中的this为obj，并且给fn传递了两个参数值1、2，</span></span><br><span class="line">但是此时并没有把fn这个函数执行;</span><br><span class="line"><span class="keyword">var</span> tempFn = fn.bind(obj, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">tempFn(); <span class="comment">//这样才把fn这个函数执行</span></span><br></pre></td></tr></table></figure>
<p><strong>bind 体现了预处理思想：事先把 fn 的 this 改变为我们想要的结果，并且把对应的参数值也准备好，以后要用到了，直接的执行即可。</strong><br>call 和 apply 直接执行函数，而 bind 需要再一次调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'Cherry'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//函数并没有执行，bind返回改变了上下文的一个函数</span></span><br><span class="line"></span><br><span class="line">b.bind(a, <span class="number">1</span>, <span class="number">2</span>)(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h4 id="箭头函数-this-指向"><a href="#箭头函数-this-指向" class="headerlink" title="箭头函数 this 指向"></a>箭头函数 this 指向</h4><p>箭头函数正如名称所示那样使用一个“箭头”(=&gt;)来定义函数的新语法，但它优于传统的函数,主要体现两点：更简短的函数并且不绑定 this。</p>
<p>箭头函数没有自己的 this，箭头函数的 this 不是调用的时候决定的，而是在定义的时候处在的对象就是它的 this。</p>
<p>箭头函数的 this 看外层的<strong>是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn1"</span>&gt;测试箭头函数this_1&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="btn2"&gt;测试箭头函数this_2&lt;/</span>button&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">'btn2'</span>);</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'kobe'</span>,</span><br><span class="line">    age: <span class="number">39</span>,</span><br><span class="line">    getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//其实this取决于最外层的箭头函数,由于obj是个对象而非函数，所以this指向为Window对象</span></span><br><span class="line">      btn2.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//window</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.getName();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  birth: <span class="number">1990</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params">year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="params">y</span> =&gt;</span> y - <span class="keyword">this</span>.birth; <span class="comment">// this.birth仍是1990</span></span><br><span class="line">    <span class="keyword">return</span> fn.call(&#123; <span class="attr">birth</span>: <span class="number">2000</span> &#125;, year);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(<span class="number">2018</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>
<h3 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title=" 原型与原型链"></a><div align=center> 原型与原型链</h3><p>与大部分面向对象语言不同，ES6 之前并没有引入类（class）的概念，JavaScript 并非通过类而是直接通过构造函数来创建实例。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</p>
<p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而<strong>构造函数需要使用 new 关键字来调用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">'孙悟空'</span>, <span class="number">18</span>, <span class="string">'男'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'旺财'</span>, <span class="number">4</span>, <span class="string">'雄'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per); <span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br></pre></td></tr></table></figure>
<p>每创建一个 Person 构造函数，在 Person 构造函数中，为每一个对象都添加了一个 sayName 方法，也就是说构造函数每执行一次就会创建一个新的 sayName 方法。这样就导致了构造函数执行一次就会创建一个新的方法。为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(prototype)</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。<br><img src="前端基础汇总2/原型.png" alt="原型"><br>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ol>
<li><p>__proto__和 constructor<br>每一个对象数据类型(普通的对象、实例、prototype……)也天生自带一个属性__proto__，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性 constructor, 它指向函数对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//顺便学习一个ES5的方法,可以获得对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>何为原型链<br>在 JavaScript 中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在 JavaScript 中是通过 prototype 对象指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
<p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到 Object 对象的原型，Object 对象的原型没有原型，如果在 Object 原型中依然没有找到，则返回 undefined。<br>使用对象的 hasOwnProperty()来检查对象自身中是否含有该属性；使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.a); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'a'</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>Object 是 JS 中所有对象数据类型的基类(最顶层的类)在 Object.prototype 上没有__proto__这个属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/原型链.png" alt="原型链"></p>
</li>
</ol>
<h3 id="DOM-事件机制"><a href="#DOM-事件机制" class="headerlink" title="DOM 事件机制"></a><div align=center>DOM 事件机制</h3><h4 id="DOM-事件级别"><a href="#DOM-事件级别" class="headerlink" title="DOM 事件级别"></a>DOM 事件级别</h4><p>DOM 级别一共可以分为四个级别：DOM0 级、DOM1 级、DOM2 级和 DOM3 级。而<strong>DOM 事件分为 3 个级别：DOM 0 级事件处理，DOM 2 级事件处理和 DOM 3 级事件处理</strong>。由于 DOM 1 级中没有事件的相关内容，所以没有 DOM 1 级事件。</p>
<ol>
<li>DOM 0 级事件<br>el.onclick=function(){}<br><strong>当希望为同一个元素/标签绑定多个同类型事件的时候（如给上面的这个 btn 元素绑定 3 个点击事件），是不被允许的</strong>。DOM0 事件绑定，给元素的事件行为绑定方法，这些方法都是在当前元素事件行为的冒泡阶段(或者目标阶段)执行的。</li>
<li>DOM 2 级事件<br>el.addEventListener(event-name, callback, useCapture)<ul>
<li>event-name: 事件名称，可以是标准的 DOM 事件</li>
<li>callback: 回调函数，当事件触发时，函数会被注入一个参数为当前的事件对象 event</li>
<li>useCapture: 默认是 false，代表事件句柄在冒泡阶段执行</li>
</ul>
</li>
<li>DOM 3 级事件<br>在 DOM 2 级事件的基础上添加了更多的事件类型。<ul>
<li>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</li>
<li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li>
<li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li>
<li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li>
<li>文本事件，当在文档中输入文本时触发，如：textInput</li>
<li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li>
<li>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</li>
<li>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</li>
<li>同时 DOM3 级事件也允许使用者自定义一些事件。</li>
</ul>
</li>
</ol>
<h4 id="DOM-事件模型和事件流"><a href="#DOM-事件模型和事件流" class="headerlink" title="DOM 事件模型和事件流"></a>DOM 事件模型和事件流</h4><p>DOM 事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p>
<ul>
<li>捕获阶段：事件从 window 对象自上而下向目标节点传播的阶段；</li>
<li>目标阶段：真正的目标节点正在处理事件的阶段；</li>
<li>冒泡阶段：事件从目标节点自下而上向 window 对象传播的阶段；</li>
</ul>
<p>捕获是从上到下，事件先从 window 对象，然后再到 document（对象），然后是 html 标签（通过 document.documentElement 获取 html 标签），然后是 body 标签（通过 document.body 获取 body 标签），然后按照普通的 html 结构一层一层往下传，最后到达目标元素。</p>
<p>而事件冒泡的流程刚好是事件捕获的逆过程。</p>
<h4 id="事件代理-事件委托"><a href="#事件代理-事件委托" class="headerlink" title="事件代理(事件委托)"></a>事件代理(事件委托)</h4><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p>
<ol>
<li>优点<ul>
<li>减少内存消耗，提高性能</li>
<li>动态绑定事件<br>用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。</li>
</ul>
</li>
<li>如何实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'list'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase === <span class="string">'li'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the content is: '</span>, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Event-对象常见的应用"><a href="#Event-对象常见的应用" class="headerlink" title="Event 对象常见的应用"></a>Event 对象常见的应用</h4><ul>
<li><p>event. preventDefault()<br><strong>如果调用这个方法，默认事件行为将不再触发</strong>。什么是默认事件呢？例如表单一点击提交按钮(submit)跳转页面、a 标签默认页面跳转或是锚点定位等。</p>
<p>很多时候我们使用 a 标签仅仅是想当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">&lt;a href=<span class="string">"javascript:;"</span>&gt;链接&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/方法二:</span></span><br><span class="line"><span class="regexp">&lt;a id="test" href="http:/</span><span class="regexp">/www.cnblogs.com"&gt;链接&lt;/</span>a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/方法三：</span></span><br><span class="line"><span class="regexp">&lt;a id="test" href="http:/</span><span class="regexp">/www.cnblogs.com"&gt;链接&lt;/</span>a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>event.stopPropagation() &amp; event.stopImmediatePropagation()<br>event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。<br>stopImmediatePropagation 既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发。而 stopPropagation 只能实现前者的效果。</p>
</li>
<li>event.target &amp; event.currentTarget<br>event.currentTarget 始终是监听事件者，而 event.target 是事件的真正发出者。</li>
</ul>
<h3 id="JavaScript-常见的六种继承方式"><a href="#JavaScript-常见的六种继承方式" class="headerlink" title="JavaScript 常见的六种继承方式"></a><div align=center>JavaScript 常见的六种继承方式</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>子类型的原型为父类型的一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person(); <span class="comment">// 子类型的原型为父类型的一个实例对象</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="number">15000</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="number">14000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1, s2);</span><br></pre></td></tr></table></figure>
<p>我们需要在子类中添加新的方法或者是重写父类的方法时候，切记一定要放到替换原型的语句之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'111'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Student.prototype.sayHello = function () &#123; &#125;//在这里写子类的原型方法和属性是无效的，</span></span><br><span class="line"><span class="comment">//因为会改变原型的指向，所以应该放到重新指定之后</span></span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="number">15000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>父类新增原型方法/原型属性，子类都能访问到</li>
<li>简单，易于实现</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法实现多继承</li>
<li>来自原型对象的所有属性被所有实例共享</li>
<li>创建子类实例时，无法向父类构造函数传参</li>
<li>要想为子类新增属性和方法，必须要在 Student.prototype = new Person() 之后执行，不能放到构造器中</li>
</ul>
<h4 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h4><p>在子类型构造函数中通用 call()调用父类型构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age); <span class="comment">// 相当于: this.Person(name, age)</span></span><br><span class="line">  <span class="comment">/*this.name = name</span></span><br><span class="line"><span class="comment">    this.age = age*/</span></span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>);</span><br></pre></td></tr></table></figure>
<p>这种方式只是实现部分的继承，如果父类的原型还有方法和属性，子类是拿不到这些方法和属性的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(s1.setAge()); <span class="comment">//Uncaught TypeError: s1.setAge is not a function</span></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>解决了原型链继承中子类实例共享父类引用属性的问题</li>
<li>创建子类实例时，可以向父类传递参数</li>
<li>可以实现多继承(call 多个父类对象)</li>
</ul>
<p>缺点：</p>
<ul>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li>
<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h4 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="headerlink" title="原型链+借用构造函数的组合继承"></a>原型链+借用构造函数的组合继承</h4><p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'111'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">//组合继承也是需要修复构造函数指向的</span></span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="string">'Jack'</span>, <span class="number">22</span>, <span class="number">14000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor); <span class="comment">//Student</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor); <span class="comment">//Person</span></span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/组合继承结果.png" alt="组合继承结果"><br>优点：</p>
<ul>
<li>可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>不存在引用属性共享问题</li>
<li>可传参</li>
<li>函数可复用</li>
</ul>
<p>缺点：</p>
<ul>
<li>调用了两次父类构造函数，生成了两份实例</li>
</ul>
<h4 id="组合继承优化-1"><a href="#组合继承优化-1" class="headerlink" title="组合继承优化 1"></a>组合继承优化 1</h4><p>这种方式通过<strong>父类原型和子类原型指向同一对象</strong>，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免的组合继承的缺点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'111'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = Person.prototype;</span><br><span class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>不会初始化两次实例方法/属性，避免的组合继承的缺点。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个。</li>
</ul>
<h4 id="组合继承优化-2"><a href="#组合继承优化-2" class="headerlink" title="组合继承优化 2"></a>组合继承优化 2</h4><p>借助原型可以基于已有的对象来创建对象，var B = Object.create(A)以 A 对象为原型，生成了 B 对象。B 继承了 A 的所有属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'111'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">  <span class="keyword">this</span>.price = price;</span><br><span class="line">  <span class="keyword">this</span>.setScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype); <span class="comment">//核心代码</span></span><br><span class="line">Student.prototype.constructor = Student; <span class="comment">//核心代码</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'Tom'</span>, <span class="number">20</span>, <span class="number">15000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1 <span class="keyword">instanceof</span> Student, s1 <span class="keyword">instanceof</span> Person); <span class="comment">// true true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.constructor); <span class="comment">//Student</span></span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br></pre></td></tr></table></figure>
<p>Student 继承了所有的 Person 原型对象的属性和方法。目前来说，最完美的继承方法！</p>
<h4 id="ES6-中-class-的继承"><a href="#ES6-中-class-的继承" class="headerlink" title="ES6 中 class 的继承"></a>ES6 中 class 的继承</h4><p>ES6 中引入了 class 关键字，class 可以通过 extends 关键字实现继承，还可以通过 static 关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<p>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</p>
<p><strong>注意：</strong> class 关键字只是原型的语法糖，JavaScript 继承仍然是基于原型实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用类的构造方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义一般的方法</span></span><br><span class="line">  showName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用父类的方法'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">'kobe'</span>, <span class="number">39</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, salary) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age); <span class="comment">//通过super调用父类的构造方法</span></span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line">  showName() &#123;</span><br><span class="line">    <span class="comment">//在子类自身定义方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用子类的方法'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Student(<span class="string">'wade'</span>, <span class="number">38</span>, <span class="number">1000000000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line">s1.showName();</span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/class继承.png" alt="class继承"><br>优点：</p>
<ul>
<li>语法简单易懂,操作更方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>并不是所有的浏览器都支持 class 关键字</li>
</ul>
<h3 id="JavaScript-线程机制与事件机制"><a href="#JavaScript-线程机制与事件机制" class="headerlink" title=" JavaScript 线程机制与事件机制"></a><div align=center> JavaScript 线程机制与事件机制</h3><p><img src="前端基础汇总2/线程事件机制.png" alt="线程事件机制"></p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ol>
<li><p>进程<br>进程是指程序的一次执行,它占有一片独有的内存空间,可以通过 windows 任务管理器查看进程。同一个时间里，同一个计算机系统中允许两个或两个以上的进程处于并行状态，这是多进程。比如电脑同时运行微信，QQ，以及各种浏览器等。<strong>浏览器运行是有些是单进程，如 firefox 和老版 IE，有些是多进程，如 chrome 和新版 IE。</strong></p>
</li>
<li><p>线程<br>有些进程还不止同时干一件事，比如 Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。<br><strong>线程是指 CPU 的基本调度单位,是程序执行的一个完整流程，是进程内的一个独立执行单元。</strong> 多线程是指在一个进程内, 同时有多个线程运行。<strong>浏览器运行是多线程</strong>。比如用浏览器一边下载，一边听歌，一边看视频。<br><strong>JavaScript 语言的一大特点就是单线程</strong>，为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。<br><img src="前端基础汇总2/线程.png" alt="线程"></p>
</li>
<li><p>进程与线程</p>
<ul>
<li><p>应用程序必须运行在某个进程的某个线程上</p>
</li>
<li><p>一个进程中至少有一个运行的线程: 主线程, 进程启动后自动创建</p>
</li>
<li><p>一个进程中如果同时运行多个线程, 那这个程序是多线程运行的</p>
</li>
<li><p>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p>
</li>
<li><p>多个进程之间的数据是不能直接共享的</p>
</li>
</ul>
</li>
<li><p>单线程与多线程的优缺点?<br>单线程的优点:顺序编程简单易懂</p>
<p>单线程的缺点:效率低</p>
<p>多线程的优点:能有效提升 CPU 的利用率</p>
<p>多线程的缺点:</p>
<ul>
<li>创建多线程开销</li>
<li>线程间切换开销</li>
<li>死锁与状态同步问题</li>
</ul>
</li>
</ol>
<h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是 JS 引擎。现在 JS 引擎比较独立，内核更加倾向于说渲染引擎。</p>
<ol>
<li>不同的浏览器可能不太一样<ul>
<li>Chrome(以前), Safari: webkit</li>
<li>chrome(现在): blink</li>
<li>firefox: Gecko</li>
<li>IE: Trident</li>
<li>360,搜狗等国内浏览器: Trident + webkit</li>
</ul>
</li>
<li>内核由很多模块组成<ul>
<li>html,css 文档解析模块 : 负责页面文本的解析</li>
<li>dom/css 模块 : 负责 dom/css 在内存中的相关处理</li>
<li>布局和渲染模块 : 负责页面的布局和效果的绘制</li>
<li>定时器模块 : 负责定时器的管理</li>
<li>网络请求模块 : 负责服务器请求(常规/Ajax)</li>
<li>事件响应模块 : 负责事件的管理</li>
</ul>
</li>
</ol>
<h4 id="定时器引发的思考"><a href="#定时器引发的思考" class="headerlink" title="定时器引发的思考"></a>定时器引发的思考</h4><ol>
<li><p>定时器真是定时执行的吗?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'启动定时器前...'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'定时器执行了'</span>, <span class="built_in">Date</span>.now() - start);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'启动定时器后...'</span>);</span><br><span class="line">  <span class="comment">// 做一个长时间的工作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/定时器.png" alt="定时器"><br>定时器并不能保证真正定时执行，一般会延迟一丁点,也有可能延迟很长时间</p>
</li>
<li>定时器回调函数是在分线程执行的吗?<br><strong>定时器回调函数在主线程执行的</strong></li>
</ol>
<h4 id="浏览器的事件循环-轮询-模型"><a href="#浏览器的事件循环-轮询-模型" class="headerlink" title="浏览器的事件循环(轮询)模型"></a>浏览器的事件循环(轮询)模型</h4><ol>
<li><p>为什么 JavaScript 是单线程<br>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
</li>
<li><p>Event Loop<br>JavaScript 中所有任务可以分成两种，一种是同步任务，另一种是异步任务(如各种浏览器事件、定时器和 Ajax 等)。<br><strong>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</strong><br>异步执行的运行机制如下：</p>
<ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步<br><strong>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）</strong></li>
</ul>
</li>
</ol>
<h4 id="H5-Web-Workers-多线程"><a href="#H5-Web-Workers-多线程" class="headerlink" title="H5 Web Workers(多线程)"></a>H5 Web Workers(多线程)</h4><ol>
<li><p>Web Workers 的作用<br>当一个页面加载一个复杂运算的 js 文件时，用户界面可能会短暂地“冻结”，不能再做其他操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"数值"</span> id=<span class="string">"number"</span>&gt;</span><br><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;计算&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  // 1 1 2 3 5 8    f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="string">  function fibonacci(n) &#123;</span></span><br><span class="line"><span class="string">    return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2)  //递归调用</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  var input = document.getElementById('number')</span></span><br><span class="line"><span class="string">  document.getElementById('btn').onclick = function () &#123;</span></span><br><span class="line"><span class="string">    var number = input.value;</span></span><br><span class="line"><span class="string">    var result = fibonacci(number);</span></span><br><span class="line"><span class="string">    alert(result);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="前端基础汇总2/计算阻塞.gif" alt="计算阻塞"><br><strong>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。</strong><br>这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。其原理图如下：<br><img src="前端基础汇总2/webworkers原理图.png" alt="webworkers原理图"></p>
</li>
<li>Web Workers 的基本使用<br><strong>主线程</strong></li>
</ol>
<ul>
<li><p>首先主线程采用 new 命令，调用 Worker()构造函数，新建一个 Worker 线程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'work.js'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后主线程调用 worker.postMessage()方法，向 Worker 发消息。</p>
</li>
<li><p>接着，主线程通过 worker.onmessage 指定监听函数，接收子线程发回来的消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'number'</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = input.value;</span><br><span class="line">  <span class="comment">//创建一个Worker对象</span></span><br><span class="line">  <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line">  <span class="comment">// 绑定接收消息的监听</span></span><br><span class="line">  worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'主线程接收分线程返回的数据: '</span> + event.data);</span><br><span class="line">    alert(event.data);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 向分线程发送消息</span></span><br><span class="line">  worker.postMessage(number);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'主线程向分线程发送数据: '</span> + number);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p><strong>Worker 线程</strong></p>
</li>
<li><p>Worker 线程内部需要有一个监听函数，监听message事件。</p>
</li>
<li>通过 postMessage(data) 方法来向主线程发送数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//worker.js文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n&lt;=<span class="number">2</span> ? <span class="number">1</span> : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)  <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>)<span class="comment">//[object DedicatedWorkerGlobalScope]</span></span><br><span class="line"><span class="keyword">this</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> number = event.data</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'分线程接收到主线程发送的数据: '</span>+number)</span><br><span class="line">  <span class="comment">//计算</span></span><br><span class="line">  <span class="keyword">var</span> result = fibonacci(number)</span><br><span class="line">  postMessage(result)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'分线程向主线程返回数据: '</span>+result)</span><br><span class="line">  <span class="comment">// alert(result)  alert是window的方法, 在分线程不能调用</span></span><br><span class="line">  <span class="comment">// 分线程中的全局对象不再是window, 所以在分线程中不可能更新界面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>Web Workers的缺点<ul>
<li>不能跨域加载JS</li>
<li>worker内代码不能访问DOM(更新UI)</li>
<li>不是每个浏览器都支持这个新特性(本文例子只能在Firefox浏览器上运行，chrome不支持)</li>
</ul>
</li>
</ol>
<h3 id="浏览器与Node的事件循环"><a href="#浏览器与Node的事件循环" class="headerlink" title=" 浏览器与Node的事件循环"></a><div align=center> 浏览器与Node的事件循环</h3></script></li></ul>
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/03/前端基础知识汇总/" rel="next" title="前端基础知识汇总（浏览器相关）">
                <i class="fa fa-chevron-left"></i> 前端基础知识汇总（浏览器相关）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangyuhao</p>
              <div class="site-description motion-element" itemprop="description">JavaScript,React,Vue</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/zhangyuhaoL" title="GitHub &rarr; https://github.com/zhangyuhaoL" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:769926882@qq.com" title="E-Mail &rarr; mailto:769926882@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前端模块化详解"><span class="nav-number">1.</span> <span class="nav-text">前端模块化详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模块化的理解"><span class="nav-number">1.1.</span> <span class="nav-text">模块化的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块化规范"><span class="nav-number">1.2.</span> <span class="nav-text">模块化规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跨域方式实现原理"><span class="nav-number">2.</span> <span class="nav-text">跨域方式实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是跨域"><span class="nav-number">2.1.</span> <span class="nav-text">什么是跨域</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangyuhao</span>

  

  
</div>







<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_pv"></span>次
  <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
